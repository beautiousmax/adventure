__author__ = 'Clara'

import random


class Map(object):
    def __init__(self, location, land, discovered_yet=False, saw_in_the_distance=False):
        self.location = location
        self.land = land
        self.discovered_yet = discovered_yet
        self.saw_in_the_distance = saw_in_the_distance

    def discovery(self):
        self.discovered_yet = True
        self.saw_in_the_distance = False
        #set neighboring squares saw_in_the_distance to True if they haven't been discovered yet


#nifty item dropper, check it out!
#makes a list of a weighted, randomly selected, list of awesome stuff.
#to be used for inventory items.
#maybe even for mobs
#or adventure stuff
"""
def dropper(rareness):
    results = {'super rare': 100,
               'rare': 50,
               'uncommon': 25,
               'common': 5,
               'super common': 2}
    for i in results:
        if rareness == i:
            return random.randint(0, results[x]) == 1


items = {"thing": "rare",
         "another thing": "common",
         "better stuff": "super rare",
         "rocks": "super common",
         "lollipops": "common"}

countdown = random.randint(0, 10)
drops = []
while countdown > 0:
    for k, x in items.items():
        if dropper(x) is True:
            drops.append(k)
    countdown -= 1

print drops
"""

master_items = {"rock": "super common",
                "stick": "common",
                "pinecone": "super common",
                "hunting knife": "uncommon",
                "emerald necklace": "super rare",
                "pixie dust": "rare",
                "broken glass": "uncommon",
                "shovel": "uncommon",
                "mushrooms": "uncommon"}

master_mobs = {"are squirrels": "common",
               "an old witch": "rare",
               "a pack of wolves": "uncommon",
               "some wood nymphs": "super rare",

               "a few cows": "common",
               "a farmer": "rare"}


## these still don't do anything, yet, but are cleaned up a bit more
class Forest(object):
    def __init__(self, mobs, description, items, name="forest"):
        self.name = name
        self.mobs = mobs
        self.items = items
        self.description = description

        description_lst = ["laced with dark magic",
                           "the home of the Tin Woodsman",
                           "filled with happy woodland animals",
                           "covered in shadow"]



class Farmland(object):
    def __init__(self, mobs, description, items, name="farmland"):
        self.name = name
        self.mobs = mobs
        self.items = items
        self.description = description


        description_lst = ["just barren fields",
                           "rows and rows of beans and squash",
                           "protected from evil by an ancient spell"]


def change_direction(direction):
    dir_shift = {"north": -10, "south": 10, "east": 1, "west": -1}
    new_loc = (current.location + dir_shift[direction])
    for place in map_squares:
        if place.location == new_loc:
            return place
    print "Can't go further %s! \n" % direction
    return current

#functionality of this will need to be expanded some
def find_neighbors():
    n = int(current.location) - 10
    e = int(current.location) + 1
    s = int(current.location) + 10
    w = int(current.location) - 1
    neighbors = [
        (n, "north"),
        (e, "east"),
        (s, "south"),
        (w, "west")]
    not_on_map = []
    on_map = []

    for i in neighbors:
        if i[0] in grid:
            on_map.append(i)
        elif i not in grid:
            not_on_map.append("nothing further %s" % i[1])

#heh yeah, tell me about it
    for i in on_map:
        for square in map_squares:
            if i == square.location:
                if square.discovered_yet is False:
                    return square.saw_in_the_distance is True

    print ', '.join(not_on_map)


def commands(words):
    global current

    if words.lower() == "help":
        print "Available commands are 'go north', 'go east', 'go south', and 'go west'"

    if words.lower() == "go north":
        current = change_direction("north")

    if words.lower() == "go east":
        current = change_direction("east")

    if words.lower() == "go south":
        current = change_direction("south")

    if words.lower() == "go west":
        current = change_direction("west")

    print "You are at %s, which is %s. \n" % (current.location, current.land)
    current.discovery()
    find_neighbors()


def start_game():
    global current
    #place player
    current = map_squares[4]
    current.discovery()
    find_neighbors()
    commands("help")
    return current

#generate map
grid = [00, 01, 02, 10, 11, 12, 20, 21, 22]
#grid to be generated by function, eventually. Maybe with individual arrays for each row?? crazy talk

land_type = ["forest", "farmland"]
#to be replaced with classes that have attributes and items in them.
#and not to be limited to forest and farmland:
#castles, small towns, swamps, mountains, the like

map_squares = []

for loc in grid:
    map_squares.append(Map(loc, (random.choice(land_type))))

start_game()
if __name__ == "__main__":
    while True:
        commands(raw_input("What would you like to do? \n"))